#
# Copyright (c) 2024 Digital Research Alliance of Canada
#
# This file is part of FRDR Encryption Application.
#
# FRDR Encryption Application is free software: you can redistribute it
# and/or modify it under the terms of the GNU General Public License as
# published by the FRDR Encryption Application Software Foundation,
# version 3 of the License.
#
# FRDR Encryption Application is distributed in the hope that it will be
# useful, but WITHOUT ANY WARRANTY; without even the implied
# warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR
# PURPOSE. See the GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with Foobar. If not, see <https://www.gnu.org/licenses/>.
#
import datetime
from util.configLoader import config
import logging

from pytz import timezone
from util.util import Util
from cryptography.hazmat.backends import default_backend
from cryptography.hazmat.primitives import serialization
from cryptography.hazmat.primitives import hashes
from cryptography.hazmat.primitives.asymmetric import padding


class DatasetKeyManager(object):
    def __init__(self, vault_client):
        """Class init function

        Args:
            vault_client (VaultClient): Wrapper of HashiCorp Vault API client
        """
        self._logger = logging.getLogger(
            "frdr-encryption-client.dataset-key-manager")
        self._vault_client = vault_client
        # key_ring_name is the user_entity_id
        self._key_ring_name = self._vault_client.entity_id
        self._key = None
        self._key_encrypted = None

    def generate_key(self):
        """Generate the dataset key using the HashiCorp Vault transit secret engine.
        """
        try:
            self._vault_client.create_transit_engine_key_ring(
                self._key_ring_name, mount_point="transit")
        except Exception as e:
            self._logger.error(
                "Falied to generate key with Vault transit secret engine. {}".format(e))
        key_plaintext = self._vault_client.generate_data_key(
            self._key_ring_name, mount_point="transit")
        self._key = Util.base64_to_byte(key_plaintext)
        self._logger.info("Key is generated by vault transit secrets engine.")

    def encrypt_key(self, user_public_key):
        """Encrypt the dataset key with the user's public key.

        Args:
            user_public_key (string): User's public key retrieved from the key server
        """
        if not isinstance(user_public_key, bytes):
            user_public_key = Util.base64_to_byte(user_public_key)
        public_key = serialization.load_pem_public_key(
            user_public_key,
            backend=default_backend()
        )
        key_encrypted = public_key.encrypt(
            self._key,
            padding.OAEP(
                mgf=padding.MGF1(algorithm=hashes.SHA256()),
                algorithm=hashes.SHA256(),
                label=None)
        )
        self._key_encrypted = Util.byte_to_base64(key_encrypted)

    def save_key(self, path):
        """Save the encrypted dataset key to the key server.

        Args:
            path (string): The path the dataset key saved on the key server
        """
        self._vault_client.save_key_to_vault(path, self._key_encrypted)
        self._logger.info("Key is saved to vault at path {}.".format(path))
    
    def delete_key(self, path):
        """Delete the encrypted dataset key saved on the key server.

        Args:
            path (string): The path to the key.
        """     
        if self._vault_client.retrive_key_from_vault(path) is not None:
            self._logger.info("Found key on path {}. Deleting it.".format(path))
            self._vault_client.delete_key_on_vault(path)

    def read_key(self, path):
        """Read the key saved at the path from the key server.

        Args:
            path (string): The path the key saved on the key server
        """
        self._key_encrypted = self._vault_client.retrive_key_from_vault(path)
        self._logger.info("key is read from vault")

    def decrypt_key(self, user_private_key):
        """Decrypt the encrypted dataset key using the user's private key.

        Args:
            user_private_key (string): User's private key saved locally
        """
        private_key = serialization.load_pem_private_key(
            user_private_key,
            password=None,
            backend=default_backend()
        )
        self._key = private_key.decrypt(
            Util.base64_to_byte(self._key_encrypted),
            padding.OAEP(
                mgf=padding.MGF1(
                    algorithm=hashes.SHA256()),
                algorithm=hashes.SHA256(),
                label=None
            )
        )

    def set_key_expiry_date(self, path, expiry_date):
        """Set the expiry date of the key saved on the key saver. 
           The key will be deleted on the key saver after the expiry date.

        Args:
            path (string): The path the key saved on the key server
            expiry_date (string): The date that the key will be deleted from 
                                  the key server, formatted in YYYY-MM-DD
        """
        tz = timezone(config.TIMEZONE)
        now = datetime.datetime.now(tz)
        # date + 1 00:00:00
        expiry_time = tz.localize(datetime.datetime.strptime(
            expiry_date, '%Y-%m-%d') + datetime.timedelta(days=1))
        diff_seconds = (expiry_time - now).total_seconds()
        self._vault_client.update_secret_metadata_delete_after(
            path, str(diff_seconds) + "s")

    def get_vault_entity_id(self):
        """Get the logged in user's ID on the key server

        Returns:
            string: The logged in user's ID on the key server
        """
        return self._vault_client.entity_id

    @property
    def key(self):
        return self._key
